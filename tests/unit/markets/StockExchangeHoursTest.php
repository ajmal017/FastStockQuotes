<?php
namespace FastStockQuotes\tests\unit\markets;

use FastStockQuotes\Markets\StockExchange;
use FastStockQuotes\utils\DateTime;
use FastStockQuotes\markets\ExchangeCodes;

use PHPUnit\Framework\TestCase;
class StockExchangeHoursTest extends TestCase {

	public static $mockDatetime;

	public function setUp()/* The :void return type declaration that should be here would cause a BC issue */ {
		parent::setUp(); // TODO: Change the autogenerated stub
		DateTime::$mockDateTimeArguementQueue = array();
	}

	const FRIDAY = "2018-01-19";
	const SATURDAY = "2018-01-20";
	const SUNDAY = "2018-01-21";
	const MONDAY = "2018-01-22";
	const TUESDAY = "2018-01-23";

	public function isOpenProvider(){
		$dateTimezone = new \DateTimeZone("America/Toronto");

		return [
			'Saturday during regular operating hours' => [self::SATURDAY . " 10:00:00", $dateTimezone, false],
			'Sunday during regular operating hours' => [self::SUNDAY . " 10:00:00", $dateTimezone, false],
			'Weekday morning before open' => [ self::MONDAY . " 6:00:00", $dateTimezone, false],
			'Weekday at open' => [ self::MONDAY . " 9:30:00", $dateTimezone, true],
			'Weekday at close' => [ self::MONDAY . " 16:00:00", $dateTimezone, true],
			'Weekday evening after close' => [ self::MONDAY . " 22:00:00", $dateTimezone, false],
			'Weekday midnight' => [ self::MONDAY . " 00:00:00", $dateTimezone, false],
			'Weekday during regular operating hours' => [ self::MONDAY . " 10:00:00", $dateTimezone, true],
		];
	}

	/**
	 * @dataProvider isOpenProvider
	 */
	public function testIsOpened($time, $dateTimezone, $shouldBeOpen){
		$stockExchange = StockExchange::fromExchangeCode(ExchangeCodes::US);

		//mock current time
		array_push(DateTime::$mockDateTimeArguementQueue, array($time, $dateTimezone));

		//mock closing and opening time for weekday
		array_push(DateTime::$mockDateTimeArguementQueue, array( self::MONDAY . " 9:30", $dateTimezone));
		array_push(DateTime::$mockDateTimeArguementQueue, array( self::MONDAY . " 16:30", $dateTimezone));

		$this->assertSame($shouldBeOpen, $stockExchange->isOpen(), $time);
	}


	public function lastCloseTimeProvider(){
		$timezone = new \DateTimeZone("America/New_York");

		$fridayAtClosingTime = self::FRIDAY . " 16:00:00";
		$fridayClosingTimestamp = (new \DateTime($fridayAtClosingTime, $timezone))->getTimestamp();

		$thursdayClosingTimestamp = $fridayClosingTimestamp - 60*60*24;

		$saturdayAtClosingTime = self::SATURDAY . " 16:00:00";
		$sundayAtClosingTime = self::SUNDAY . " 16:00:00";

		return [
			"Friday after closing should return same day's closing time" => array($fridayAtClosingTime, self::FRIDAY . " 17:00:00", $fridayClosingTimestamp, $timezone),
			"Friday before closing should return thursday's closing time" => array($fridayAtClosingTime, self::FRIDAY . " 15:00:00", $thursdayClosingTimestamp, $timezone),
			"Saturday after 16:00 should return friday's closing time" => array($saturdayAtClosingTime, self::SATURDAY . " 17:00:00", $fridayClosingTimestamp, $timezone),
			"Saturday before 16:00 should return friday's closing time" => array($saturdayAtClosingTime, self::SATURDAY . " 15:00:00", $fridayClosingTimestamp, $timezone),
			"Saturday at 16:00 should return friday's closing time" => array($saturdayAtClosingTime, self::SATURDAY . " 16:00:00", $fridayClosingTimestamp, $timezone),
			"Sunday after 16:00 should return friday's closing time" => array($sundayAtClosingTime, self::SUNDAY . " 17:00:00", $fridayClosingTimestamp, $timezone),
			"Sunday before 16:00 should return friday's closing time" => array($sundayAtClosingTime, self::SUNDAY . " 15:00:00", $fridayClosingTimestamp, $timezone),
			"Sunday at 16:00 should return friday's closing time" => array($sundayAtClosingTime, self::SUNDAY . " 16:00:00", $fridayClosingTimestamp, $timezone),
		];
	}

	/**
	 * @dataProvider lastCloseTimeProvider
	 */
	public function testLastCloseTimeAfterCloseSameDay($currentDayClosingTime, $currentTime, $expectedLastClosingTimestamp, $timezone){
		$stockExchange = StockExchange::fromExchangeCode(ExchangeCodes::US);

		array_push(DateTime::$mockDateTimeArguementQueue, array($currentTime, $timezone));
		array_push(DateTime::$mockDateTimeArguementQueue, array($currentDayClosingTime, $timezone));

		$actualLastClosingTimestamp = $stockExchange->timestampOfLastClose();

		$this->assertSame($expectedLastClosingTimestamp, $actualLastClosingTimestamp,  "Current time: " . $currentTime . ", Closing time on current day " . $currentDayClosingTime);
	}


	public function secondsUntilOpenDataProvider(){

		return [
			"Weekday before open" => [self::MONDAY . " 9:29", self::MONDAY . " 9:30", null, 60*1],
			"Weekday at open" => [self::MONDAY . " 9:30", self::MONDAY . " 9:30", null, 60*0],
			"Weekday while open" => [self::MONDAY . " 10:30", self::TUESDAY . " 9:30", null, 60*60*23],
			"Weekday at close" => [self::MONDAY . " 16:00", self::TUESDAY . " 9:30", null, (8+9)*60*60+60*30],
			"Weekday after close" => [self::MONDAY . " 16:01", self::TUESDAY . " 9:30", null, (8+9)*60*60+60*29],
			"Friday before open" => [self::FRIDAY . " 9:29", self::FRIDAY . " 9:30", self::MONDAY . " 9:30", 60],
			"Friday at open" => [self::FRIDAY . " 9:30", self::FRIDAY . " 9:30", self::MONDAY . " 9:30", 0],
			"Friday after open" => [self::FRIDAY . " 10:30", self::FRIDAY . " 9:30", self::MONDAY . " 9:30", (14+9)*60*60+60*60*24*2],
			"Friday at close" => [self::FRIDAY . " 16:00", self::FRIDAY . " 9:30", self::MONDAY . " 9:30", (8+9)*60*60+60*60*24*2+60*30],
			"Friday after close" => [self::FRIDAY . " 16:01", self::FRIDAY . " 9:30", self::MONDAY . " 9:30", (8+9)*60*60+60*60*24*2+60*29],
			"Weekend before open" => [self::SUNDAY . " 9:29", self::SUNDAY . " 9:30", self::MONDAY . " 9:30", 60*60*24+60*1],
			"Weekend at open" => [self::SUNDAY . " 9:30", self::SUNDAY . " 9:30", self::MONDAY . " 9:30", 60*60*24],
			"Weekend after open" => [self::SUNDAY . " 10:30", self::SUNDAY . " 9:30", self::MONDAY . " 9:30", 60*60*23],
			"Weekend at close" => [self::SUNDAY . " 16:00", self::SUNDAY . " 9:30", self::MONDAY . " 9:30", (8+9)*60*60+60*30],
			"Weekend after close" => [self::SUNDAY . " 16:01", self::SUNDAY . " 9:30", self::MONDAY . " 9:30", (8+9)*60*60+60*29],
		];

	}

	/**
	 * @dataProvider secondsUntilOpenDataProvider
	 *
	 * @throws \FastStockQuotes\exceptions\InvalidExchangeCodeException
	 */
	public function testSecondsUntilNextOpen($currentTimeStr, $openTimeTodayStr, $nextMondayStr, $expectedSecondsUntilOpen){
		$stockExchange = StockExchange::fromExchangeCode(ExchangeCodes::US);

		$tz = new \DateTimeZone("America/Toronto");
		array_push(DateTime::$mockDateTimeArguementQueue, [$currentTimeStr, $tz]);
		array_push(DateTime::$mockDateTimeArguementQueue, [$openTimeTodayStr, $tz]);
		array_push(DateTime::$mockDateTimeArguementQueue, [$nextMondayStr, $tz]);

		$actualSecondsUntilNextOpen = $stockExchange->secondsUntilNextOpen();
		$this->assertSame($expectedSecondsUntilOpen, $actualSecondsUntilNextOpen, "seconds until next open should match");
	}

}